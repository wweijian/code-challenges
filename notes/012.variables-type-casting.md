### Variables & Data Types

## Type Casting

### C++ (Multiple Cast Types)

#### C-style cast
Avoid in modern C++
```cpp
int x = 5;
double y = (double)x;
```

#### static_cast
Most common, compile-time
```cpp
double z = static_cast<double>(x);
int a = static_cast<int>(3.14);     // 3
```

#### dynamic_cast
Runtime type checking, for polymorphism
```cpp
Base* basePtr = new Derived();
Derived* derivedPtr = dynamic_cast<Derived*>(basePtr);
if (derivedPtr != nullptr) {
    // Safe to use
}
```

#### const_cast
Remove const qualifier
```cpp
const int* constPtr = &x;
int* modifiablePtr = const_cast<int*>(constPtr);
```

#### reinterpret_cast
Dangerous, low-level
```cpp
int num = 65;
char* charPtr = reinterpret_cast<char*>(&num);
```

#### Implicit conversion
```cpp
int i = 42;
double d = i;       // Implicit conversion OK
```

#### Explicit constructor
```cpp
std::string str = std::string("hello");
```

---

### Python (Duck Typing + Explicit Conversion)

#### Explicit type conversion
```python
x = 5
y = float(x)        # 5.0
z = str(x)          # "5"
a = int(3.14)       # 3
b = bool(0)         # False
c = list("abc")     # ['a', 'b', 'c']
```

#### No type casting needed
Duck typing
```python
def process(value):
    return value * 2

process(5)          # 10
process("hi")       # "hihi"
process([1, 2])     # [1, 2, 1, 2]
```

#### Type checking
Runtime
```python
x = 5
if isinstance(x, int):
    print("It's an integer")
```

#### Type assertion
For type checkers, not runtime
```python
from typing import cast
x: object = "hello"
y: str = cast(str, x)   # Just tells type checker
```

#### Convert between collections
```python
my_list = [1, 2, 3]
my_tuple = tuple(my_list)
my_set = set(my_list)
my_dict = dict(zip(['a', 'b'], [1, 2]))
```

---

### Julia (Convert vs Cast)

#### convert()
Safe conversion
```julia
x = 5
y = convert(Float64, x)     # 5.0
z = convert(Int, 3.0)       # 3
# convert(Int, 3.5)         # InexactError!
```

#### Type assertion
Using ::
```julia
x = 5
y = x::Int64                # Asserts x is Int64
# x::Float64                # TypeError!
```

#### Promotion
Automatic
```julia
x = 1 + 2.0                 # Float64: 3.0 (promotes Int to Float)
```

#### Explicit constructors
```julia
x = Float64(5)              # 5.0
y = Int64(3.0)              # 3
z = String([72, 105])       # "Hi"
```

#### parse()
For strings
```julia
x = parse(Int, "123")       # 123
y = parse(Float64, "3.14")  # 3.14
```

#### Type checking
```julia
x = 5
if x isa Int64
    println("It's an Int64")
end
```

#### typeof()
For type inspection
```julia
typeof(5)                   # Int64
typeof(3.14)                # Float64
```

#### Union types
Can be multiple types
```julia
x::Union{Int, String} = 5
x = "hello"                 # Also valid
```

#### Abstract types
```julia
function process(x::Real)   # Accepts any real number
    return x * 2
end
```

---

### TypeScript (Type Assertions)

#### Type assertion
Doesn't change runtime value
```typescript
let value: any = "hello";
let strLength: number = (value as string).length;
let strLength2: number = (<string>value).length;  // Alternative syntax
```

#### Type casting for primitives
JavaScript conversion
```typescript
let x: number = 5;
let y: string = x.toString();
let z: string = String(x);

let str: string = "123";
let num: number = Number(str);      // 123
let num2: number = parseInt(str);   // 123
let num3: number = parseFloat("3.14");  // 3.14
```

#### Boolean conversion
```typescript
let bool1: boolean = Boolean(0);        // false
let bool2: boolean = Boolean("text");   // true
```

#### Type guards
Runtime checking
```typescript
function process(value: string | number) {
    if (typeof value === "string") {
        return value.toUpperCase();    // TS knows it's string
    } else {
        return value * 2;              // TS knows it's number
    }
}
```

#### instanceof
For classes
```typescript
class Dog {}
class Cat {}

function identify(animal: Dog | Cat) {
    if (animal instanceof Dog) {
        // animal is Dog here
    }
}
```

#### User-defined type guards
```typescript
function isString(value: any): value is string {
    return typeof value === "string";
}
```

#### Non-null assertion
```typescript
let maybeString: string | null = "hello";
let length: number = maybeString!.length;  // Asserts not null
```

#### const assertions
Literal type
```typescript
let x = "hello" as const;       // Type is "hello", not string
let arr = [1, 2] as const;      // Readonly tuple [1, 2]
```

#### satisfies operator
Type checking without widening
```typescript
const config = {
    url: "https://api.com",
    timeout: 5000
} satisfies Record<string, string | number>;
```

---

## Casting Comparison Summary

| Feature | C++ | Python | Julia | TypeScript |
|---------|-----|--------|-------|------------|
| **Safety Level** | Multiple levels | Safe (duck typing) | Safe with convert | Compile-time only |
| **Main Method** | `static_cast<T>()` | `type(value)` | `convert(T, x)` | `as` or `<type>` |
| **Runtime Check** | `dynamic_cast` | `isinstance()` | `isa` | `typeof`, `instanceof` |
| **String to Number** | `stoi()`, `stod()` | `int()`, `float()` | `parse(T, str)` | `Number()`, `parseInt()` |
| **Number to String** | `to_string()` | `str()` | `string()` | `toString()`, `String()` |
| **Type Assertion** | Templates | Type hints | `::` operator | `as`, `!` |

## Key Differences

### C++
- **Most explicit** - many cast types for different scenarios
- **Compile-time safety** with `static_cast`
- **Runtime safety** with `dynamic_cast`
- **Fine-grained control** over memory and access

### Python
- **No real casting** - uses duck typing
- **Type conversion** instead of casting
- **Runtime type checking** with `isinstance()`
- **Type hints don't enforce**, just for tooling

### Julia
- **`convert()` for safe conversion** - errors if impossible
- **Type assertions** with `::` for optimization
- **Multiple dispatch** based on types
- **Performance-focused** type system

### TypeScript
- **Compile-time only** - no runtime effect
- **Type assertions** tell compiler, not runtime
- **JavaScript conversion** methods for actual casting
- **Type guards** for runtime checking