## Switch/Match Statements

### C++

Traditional switch statement with fall-through behavior. Limited to integral and enum types.

#### Basic switch

```cpp
int day = 3;
switch (day) {
    case 1:
        cout << "Monday" << endl;
        break;
    case 2:
        cout << "Tuesday" << endl;
        break;
    case 3:
        cout << "Wednesday" << endl;
        break;
    default:
        cout << "Other day" << endl;
}
```

#### Fall-through (intentional, no break)

```cpp
switch (day) {
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
        cout << "Weekday" << endl;
        break;
    case 6:
    case 7:
        cout << "Weekend" << endl;
        break;
}
```

#### With initialization (C++17)

```cpp
switch (int value = getValue(); value) {
    case 0:
        cout << "Zero" << endl;
        break;
    case 1:
        cout << "One" << endl;
        break;
}
```

#### Switch with enum

```cpp
enum Color { RED, GREEN, BLUE };
Color c = GREEN;
switch (c) {
    case RED:
        cout << "Red" << endl;
        break;
    case GREEN:
        cout << "Green" << endl;
        break;
    case BLUE:
        cout << "Blue" << endl;
        break;
}
```

#### Switch with character

```cpp
char grade = 'B';
switch (grade) {
    case 'A':
        cout << "Excellent" << endl;
        break;
    case 'B':
        cout << "Good" << endl;
        break;
    case 'C':
        cout << "Average" << endl;
        break;
    default:
        cout << "Below average" << endl;
}
```

#### Nested switch

```cpp
switch (category) {
    case FRUIT:
        switch (type) {
            case APPLE:
                cout << "Apple" << endl;
                break;
            case BANANA:
                cout << "Banana" << endl;
                break;
        }
        break;
    case VEGETABLE:
        cout << "Vegetable" << endl;
        break;
}
```

### Python

Uses match-case (Python 3.10+). More powerful pattern matching than traditional switch.

#### Basic match-case (Python 3.10+)

```python
day = 3
match day:
    case 1:
        print("Monday")
    case 2:
        print("Tuesday")
    case 3:
        print("Wednesday")
    case _:
        print("Other day")
```

#### Multiple values (OR pattern)

```python
match day:
    case 1 | 2 | 3 | 4 | 5:
        print("Weekday")
    case 6 | 7:
        print("Weekend")
```

#### Pattern matching with types

```python
def process(value):
    match value:
        case int():
            print("Integer")
        case str():
            print("String")
        case list():
            print("List")
        case _:
            print("Other type")
```

#### Destructuring patterns

```python
point = (0, 0)
match point:
    case (0, 0):
        print("Origin")
    case (0, y):
        print(f"On Y-axis at {y}")
    case (x, 0):
        print(f"On X-axis at {x}")
    case (x, y):
        print(f"Point at ({x}, {y})")
```

#### Match with guard (if condition)

```python
match point:
    case (x, y) if x == y:
        print("On diagonal")
    case (x, y):
        print("Not on diagonal")
```

#### Class pattern matching

```python
class Point:
    def __init__(self, x, y):
        self.x = x
        self.y = y

match obj:
    case Point(x=0, y=0):
        print("Origin")
    case Point(x=0, y=y):
        print(f"Y-axis: {y}")
    case Point(x=x, y=0):
        print(f"X-axis: {x}")
```

#### Dictionary patterns

```python
config = {"host": "localhost", "port": 8080}
match config:
    case {"host": host, "port": port}:
        print(f"Connecting to {host}:{port}")
    case {"host": host}:
        print(f"Using default port for {host}")
```

#### List patterns

```python
items = [1, 2, 3, 4, 5]
match items:
    case []:
        print("Empty")
    case [first]:
        print(f"One item: {first}")
    case [first, second]:
        print(f"Two items: {first}, {second}")
    case [first, *rest]:
        print(f"First: {first}, Rest: {rest}")
```

#### Pre-3.10 alternative: dictionary dispatch

```python
def monday_handler():
    print("Monday")

def tuesday_handler():
    print("Tuesday")

day_handlers = {
    1: monday_handler,
    2: tuesday_handler,
}

handler = day_handlers.get(day, lambda: print("Unknown"))
handler()
```

### Julia

No built-in switch statement. Uses if-elseif chains or dictionaries.

#### If-elseif chain (most common)

```julia
day = 3
if day == 1
    println("Monday")
elseif day == 2
    println("Tuesday")
elseif day == 3
    println("Wednesday")
else
    println("Other day")
end
```

#### Multiple values using in

```julia
if day in [1, 2, 3, 4, 5]
    println("Weekday")
elseif day in [6, 7]
    println("Weekend")
end
```

#### Dictionary dispatch pattern

```julia
day_names = Dict(
    1 => "Monday",
    2 => "Tuesday",
    3 => "Wednesday",
    4 => "Thursday",
    5 => "Friday",
    6 => "Saturday",
    7 => "Sunday"
)
println(get(day_names, day, "Unknown"))
```

#### Dictionary with functions

```julia
day_handlers = Dict(
    1 => () -> println("Monday"),
    2 => () -> println("Tuesday"),
    3 => () -> println("Wednesday")
)
handler = get(day_handlers, day, () -> println("Unknown"))
handler()
```

#### Multiple dispatch (Julia's unique feature)

```julia
process(x::Int) = println("Integer: $x")
process(x::String) = println("String: $x")
process(x::Float64) = println("Float: $x")

process(42)
process("hello")
process(3.14)
```

#### Pattern matching with if-else and type checking

```julia
value = "test"
if value isa Int
    println("Integer")
elseif value isa String
    println("String")
elseif value isa Array
    println("Array")
else
    println("Other type")
end
```

#### Ternary for simple cases

```julia
result = day == 1 ? "Monday" :
         day == 2 ? "Tuesday" :
         day == 3 ? "Wednesday" :
         "Other"
println(result)
```

### TypeScript

Traditional switch statement with fall-through. No pattern matching (yet).

#### Basic switch

```typescript
let day: number = 3;
switch (day) {
    case 1:
        console.log("Monday");
        break;
    case 2:
        console.log("Tuesday");
        break;
    case 3:
        console.log("Wednesday");
        break;
    default:
        console.log("Other day");
}
```

#### Fall-through (intentional)

```typescript
switch (day) {
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
        console.log("Weekday");
        break;
    case 6:
    case 7:
        console.log("Weekend");
        break;
}
```

#### Switch with string

```typescript
let grade: string = "B";
switch (grade) {
    case "A":
        console.log("Excellent");
        break;
    case "B":
        console.log("Good");
        break;
    case "C":
        console.log("Average");
        break;
    default:
        console.log("Below average");
}
```

#### Switch with enum

```typescript
enum Color { Red, Green, Blue }
let color: Color = Color.Green;
switch (color) {
    case Color.Red:
        console.log("Red");
        break;
    case Color.Green:
        console.log("Green");
        break;
    case Color.Blue:
        console.log("Blue");
        break;
}
```

#### Switch with type checking (using typeof)

```typescript
let value: any = "hello";
switch (typeof value) {
    case "string":
        console.log("String");
        break;
    case "number":
        console.log("Number");
        break;
    case "boolean":
        console.log("Boolean");
        break;
    default:
        console.log("Other type");
}
```

#### Switch with return (no break needed)

```typescript
function getDayName(day: number): string {
    switch (day) {
        case 1: return "Monday";
        case 2: return "Tuesday";
        case 3: return "Wednesday";
        default: return "Unknown";
    }
}
```

#### Object literal pattern (alternative to switch)

```typescript
const dayNames: { [key: number]: string } = {
    1: "Monday",
    2: "Tuesday",
    3: "Wednesday",
};
console.log(dayNames[day] ?? "Unknown");
```

#### Dictionary dispatch with functions

```typescript
const handlers: { [key: number]: () => void } = {
    1: () => console.log("Monday"),
    2: () => console.log("Tuesday"),
    3: () => console.log("Wednesday"),
};
(handlers[day] ?? (() => console.log("Unknown")))();
```

#### Nested switch

```typescript
switch (category) {
    case "fruit":
        switch (type) {
            case "apple":
                console.log("Apple");
                break;
            case "banana":
                console.log("Banana");
                break;
        }
        break;
    case "vegetable":
        console.log("Vegetable");
        break;
}
```