### Control Flow Structures

## While Loops

### C++

Traditional while and do-while loops available.

#### Basic while loop

```cpp
int i = 0;
while (i < 10) {
    cout << i << " ";
    i++;
}
```

#### While with complex condition

```cpp
while (i < 10 && flag) {
    i++;
}
```

#### Do-while (executes at least once)

```cpp
int j = 0;
do {
    cout << j << " ";
    j++;
} while (j < 10);
```

#### Infinite loop with break

```cpp
while (true) {
    if (condition) break;
}
```

#### While with continue

```cpp
int k = 0;
while (k < 10) {
    k++;
    if (k % 2 == 0) continue;
    cout << k << " ";
}
```

#### Reading until condition

```cpp
string input;
while (cin >> input && input != "quit") {
    cout << "You entered: " << input << endl;
}
```

#### While with assignment

```cpp
while ((input = getInput()) != "") {
    process(input);
}
```

### Python

Only while loops available. No do-while construct.

#### Basic while loop

```python
i = 0
while i < 10:
    print(i, end=" ")
    i += 1
```

#### While with complex condition

```python
while i < 10 and flag:
    i += 1
```

#### Infinite loop with break

```python
while True:
    if condition:
        break
```

#### While with continue

```python
k = 0
while k < 10:
    k += 1
    if k % 2 == 0:
        continue
    print(k, end=" ")
```

#### While-else

Executes if loop completes without break.

```python
i = 0
while i < 5:
    print(i)
    i += 1
else:
    print("Loop completed normally")
```

#### Simulating do-while

```python
i = 0
while True:
    print(i)
    i += 1
    if i >= 10:
        break
```

#### While with walrus operator

```python
while (line := input("Enter text: ")) != "quit":
    print(f"You entered: {line}")
```

### Julia

While loops with `end` keyword. No do-while construct.

#### Basic while loop

```julia
i = 0
while i < 10
    print("$i ")
    global i += 1
end
```

#### While with complex condition

```julia
while i < 10 && flag
    global i += 1
end
```

#### Infinite loop with break

```julia
while true
    if condition
        break
    end
end
```

#### While with continue

```julia
k = 0
while k < 10
    global k += 1
    if k % 2 == 0
        continue
    end
    print("$k ")
end
```

#### Simulating do-while

```julia
i = 0
while true
    println(i)
    global i += 1
    if i >= 10
        break
    end
end
```

#### While reading input

```julia
while (line = readline()) != "quit"
    println("You entered: $line")
end
```

### TypeScript

Traditional while and do-while loops available.

#### Basic while loop

```typescript
let i: number = 0;
while (i < 10) {
    console.log(i);
    i++;
}
```

#### While with complex condition

```typescript
while (i < 10 && flag) {
    i++;
}
```

#### Do-while (executes at least once)

```typescript
let j: number = 0;
do {
    console.log(j);
    j++;
} while (j < 10);
```

#### Infinite loop with break

```typescript
while (true) {
    if (condition) break;
}
```

#### While with continue

```typescript
let k: number = 0;
while (k < 10) {
    k++;
    if (k % 2 === 0) continue;
    console.log(k);
}
```

#### While with assignment

```typescript
let input: string;
while ((input = getInput()) !== "") {
    process(input);
}
```

#### While with optional chaining

```typescript
while (obj?.hasNext?.()) {
    let item = obj.next();
}
```

## Switch/Match Statements

### C++

Traditional switch statement with fall-through behavior. Limited to integral and enum types.

#### Basic switch

```cpp
int day = 3;
switch (day) {
    case 1:
        cout << "Monday" << endl;
        break;
    case 2:
        cout << "Tuesday" << endl;
        break;
    case 3:
        cout << "Wednesday" << endl;
        break;
    default:
        cout << "Other day" << endl;
}
```

#### Fall-through (intentional, no break)

```cpp
switch (day) {
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
        cout << "Weekday" << endl;
        break;
    case 6:
    case 7:
        cout << "Weekend" << endl;
        break;
}
```

#### With initialization (C++17)

```cpp
switch (int value = getValue(); value) {
    case 0:
        cout << "Zero" << endl;
        break;
    case 1:
        cout << "One" << endl;
        break;
}
```

#### Switch with enum

```cpp
enum Color { RED, GREEN, BLUE };
Color c = GREEN;
switch (c) {
    case RED:
        cout << "Red" << endl;
        break;
    case GREEN:
        cout << "Green" << endl;
        break;
    case BLUE:
        cout << "Blue" << endl;
        break;
}
```

#### Switch with character

```cpp
char grade = 'B';
switch (grade) {
    case 'A':
        cout << "Excellent" << endl;
        break;
    case 'B':
        cout << "Good" << endl;
        break;
    case 'C':
        cout << "Average" << endl;
        break;
    default:
        cout << "Below average" << endl;
}
```

#### Nested switch

```cpp
switch (category) {
    case FRUIT:
        switch (type) {
            case APPLE:
                cout << "Apple" << endl;
                break;
            case BANANA:
                cout << "Banana" << endl;
                break;
        }
        break;
    case VEGETABLE:
        cout << "Vegetable" << endl;
        break;
}
```

### Python

Uses match-case (Python 3.10+). More powerful pattern matching than traditional switch.

#### Basic match-case (Python 3.10+)

```python
day = 3
match day:
    case 1:
        print("Monday")
    case 2:
        print("Tuesday")
    case 3:
        print("Wednesday")
    case _:
        print("Other day")
```

#### Multiple values (OR pattern)

```python
match day:
    case 1 | 2 | 3 | 4 | 5:
        print("Weekday")
    case 6 | 7:
        print("Weekend")
```

#### Pattern matching with types

```python
def process(value):
    match value:
        case int():
            print("Integer")
        case str():
            print("String")
        case list():
            print("List")
        case _:
            print("Other type")
```

#### Destructuring patterns

```python
point = (0, 0)
match point:
    case (0, 0):
        print("Origin")
    case (0, y):
        print(f"On Y-axis at {y}")
    case (x, 0):
        print(f"On X-axis at {x}")
    case (x, y):
        print(f"Point at ({x}, {y})")
```

#### Match with guard (if condition)

```python
match point:
    case (x, y) if x == y:
        print("On diagonal")
    case (x, y):
        print("Not on diagonal")
```

#### Class pattern matching

```python
class Point:
    def __init__(self, x, y):
        self.x = x
        self.y = y

match obj:
    case Point(x=0, y=0):
        print("Origin")
    case Point(x=0, y=y):
        print(f"Y-axis: {y}")
    case Point(x=x, y=0):
        print(f"X-axis: {x}")
```

#### Dictionary patterns

```python
config = {"host": "localhost", "port": 8080}
match config:
    case {"host": host, "port": port}:
        print(f"Connecting to {host}:{port}")
    case {"host": host}:
        print(f"Using default port for {host}")
```

#### List patterns

```python
items = [1, 2, 3, 4, 5]
match items:
    case []:
        print("Empty")
    case [first]:
        print(f"One item: {first}")
    case [first, second]:
        print(f"Two items: {first}, {second}")
    case [first, *rest]:
        print(f"First: {first}, Rest: {rest}")
```

#### Pre-3.10 alternative: dictionary dispatch

```python
def monday_handler():
    print("Monday")

def tuesday_handler():
    print("Tuesday")

day_handlers = {
    1: monday_handler,
    2: tuesday_handler,
}

handler = day_handlers.get(day, lambda: print("Unknown"))
handler()
```

### Julia

No built-in switch statement. Uses if-elseif chains or dictionaries.

#### If-elseif chain (most common)

```julia
day = 3
if day == 1
    println("Monday")
elseif day == 2
    println("Tuesday")
elseif day == 3
    println("Wednesday")
else
    println("Other day")
end
```

#### Multiple values using in

```julia
if day in [1, 2, 3, 4, 5]
    println("Weekday")
elseif day in [6, 7]
    println("Weekend")
end
```

#### Dictionary dispatch pattern

```julia
day_names = Dict(
    1 => "Monday",
    2 => "Tuesday",
    3 => "Wednesday",
    4 => "Thursday",
    5 => "Friday",
    6 => "Saturday",
    7 => "Sunday"
)
println(get(day_names, day, "Unknown"))
```

#### Dictionary with functions

```julia
day_handlers = Dict(
    1 => () -> println("Monday"),
    2 => () -> println("Tuesday"),
    3 => () -> println("Wednesday")
)
handler = get(day_handlers, day, () -> println("Unknown"))
handler()
```

#### Multiple dispatch (Julia's unique feature)

```julia
process(x::Int) = println("Integer: $x")
process(x::String) = println("String: $x")
process(x::Float64) = println("Float: $x")

process(42)
process("hello")
process(3.14)
```

#### Pattern matching with if-else and type checking

```julia
value = "test"
if value isa Int
    println("Integer")
elseif value isa String
    println("String")
elseif value isa Array
    println("Array")
else
    println("Other type")
end
```

#### Ternary for simple cases

```julia
result = day == 1 ? "Monday" :
         day == 2 ? "Tuesday" :
         day == 3 ? "Wednesday" :
         "Other"
println(result)
```

### TypeScript

Traditional switch statement with fall-through. No pattern matching (yet).

#### Basic switch

```typescript
let day: number = 3;
switch (day) {
    case 1:
        console.log("Monday");
        break;
    case 2:
        console.log("Tuesday");
        break;
    case 3:
        console.log("Wednesday");
        break;
    default:
        console.log("Other day");
}
```

#### Fall-through (intentional)

```typescript
switch (day) {
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
        console.log("Weekday");
        break;
    case 6:
    case 7:
        console.log("Weekend");
        break;
}
```

#### Switch with string

```typescript
let grade: string = "B";
switch (grade) {
    case "A":
        console.log("Excellent");
        break;
    case "B":
        console.log("Good");
        break;
    case "C":
        console.log("Average");
        break;
    default:
        console.log("Below average");
}
```

#### Switch with enum

```typescript
enum Color { Red, Green, Blue }
let color: Color = Color.Green;
switch (color) {
    case Color.Red:
        console.log("Red");
        break;
    case Color.Green:
        console.log("Green");
        break;
    case Color.Blue:
        console.log("Blue");
        break;
}
```

#### Switch with type checking (using typeof)

```typescript
let value: any = "hello";
switch (typeof value) {
    case "string":
        console.log("String");
        break;
    case "number":
        console.log("Number");
        break;
    case "boolean":
        console.log("Boolean");
        break;
    default:
        console.log("Other type");
}
```

#### Switch with return (no break needed)

```typescript
function getDayName(day: number): string {
    switch (day) {
        case 1: return "Monday";
        case 2: return "Tuesday";
        case 3: return "Wednesday";
        default: return "Unknown";
    }
}
```

#### Object literal pattern (alternative to switch)

```typescript
const dayNames: { [key: number]: string } = {
    1: "Monday",
    2: "Tuesday",
    3: "Wednesday",
};
console.log(dayNames[day] ?? "Unknown");
```

#### Dictionary dispatch with functions

```typescript
const handlers: { [key: number]: () => void } = {
    1: () => console.log("Monday"),
    2: () => console.log("Tuesday"),
    3: () => console.log("Wednesday"),
};
(handlers[day] ?? (() => console.log("Unknown")))();
```

#### Nested switch

```typescript
switch (category) {
    case "fruit":
        switch (type) {
            case "apple":
                console.log("Apple");
                break;
            case "banana":
                console.log("Banana");
                break;
        }
        break;
    case "vegetable":
        console.log("Vegetable");
        break;
}
```

## Break and Continue

### C++

Both break and continue work in all loop types. Break also exits switch statements.

#### Break - exits loop immediately

```cpp
for (int i = 0; i < 10; i++) {
    if (i == 5) break;
    cout << i << " ";
}
```

#### Continue - skips to next iteration

```cpp
for (int i = 0; i < 10; i++) {
    if (i % 2 == 0) continue;
    cout << i << " ";
}
```

#### Break in while loop

```cpp
int i = 0;
while (true) {
    if (i == 5) break;
    cout << i << " ";
    i++;
}
```

#### Continue in while loop

```cpp
i = 0;
while (i < 10) {
    i++;
    if (i % 2 == 0) continue;
    cout << i << " ";
}
```

#### Break in nested loops (only breaks inner loop)

```cpp
for (int i = 0; i < 3; i++) {
    for (int j = 0; j < 3; j++) {
        if (j == 2) break;
        cout << "(" << i << "," << j << ") ";
    }
    cout << endl;
}
```

#### Using goto to break outer loop

```cpp
for (int i = 0; i < 3; i++) {
    for (int j = 0; j < 3; j++) {
        if (i == 1 && j == 1) goto outer;
        cout << "(" << i << "," << j << ") ";
    }
}
outer:
cout << "Exited" << endl;
```

#### Break in switch

```cpp
switch (value) {
    case 1:
        cout << "One" << endl;
        break;
    case 2:
        cout << "Two" << endl;
        break;
}
```

### Python

Break and continue work in for and while loops. Supports else clause on loops.

#### Break - exits loop immediately

```python
for i in range(10):
    if i == 5:
        break
    print(i, end=" ")
```

#### Continue - skips to next iteration

```python
for i in range(10):
    if i % 2 == 0:
        continue
    print(i, end=" ")
```

#### Break in while loop

```python
i = 0
while True:
    if i == 5:
        break
    print(i, end=" ")
    i += 1
```

#### Continue in while loop

```python
i = 0
while i < 10:
    i += 1
    if i % 2 == 0:
        continue
    print(i, end=" ")
```

#### else clause - executes if loop completes without break

```python
for i in range(5):
    if i == 10:
        break
else:
    print("Loop completed normally")

for i in range(5):
    if i == 3:
        break
else:
    print("Loop completed normally")
```

#### Break in nested loops (only breaks inner loop)

```python
for i in range(3):
    for j in range(3):
        if j == 2:
            break
        print(f"({i},{j})", end=" ")
    print()
```

#### Breaking outer loop with flag

```python
found = False
for i in range(3):
    for j in range(3):
        if i == 1 and j == 1:
            found = True
            break
    if found:
        break
```

#### Breaking outer loop with exception

```python
class BreakOut(Exception):
    pass

try:
    for i in range(3):
        for j in range(3):
            if i == 1 and j == 1:
                raise BreakOut
except BreakOut:
    pass
```

#### Pass statement (does nothing, placeholder)

```python
for i in range(5):
    if i == 3:
        pass
    print(i)
```

### Julia

Break and continue work similarly to other languages. No else clause on loops.

#### Break - exits loop immediately

```julia
for i in 0:9
    if i == 5
        break
    end
    print("$i ")
end
```

#### Continue - skips to next iteration

```julia
for i in 0:9
    if i % 2 == 0
        continue
    end
    print("$i ")
end
```

#### Break in while loop

```julia
i = 0
while true
    if i == 5
        break
    end
    print("$i ")
    global i += 1
end
```

#### Continue in while loop

```julia
i = 0
while i < 10
    global i += 1
    if i % 2 == 0
        continue
    end
    print("$i ")
end
```

#### Break in nested loops (only breaks inner loop)

```julia
for i in 1:3
    for j in 1:3
        if j == 2
            break
        end
        print("($i,$j) ")
    end
    println()
end
```

#### Using @goto to break outer loop

```julia
for i in 1:3
    for j in 1:3
        if i == 1 && j == 1
            @goto outer
        end
        print("($i,$j) ")
    end
end
@label outer
println("Exited")
```

#### Early return from function (alternative to break)

```julia
function find_value(arr, target)
    for (i, val) in enumerate(arr)
        if val == target
            return i
        end
    end
    return nothing
end
```

### TypeScript

Break and continue work in all loop types. No else clause on loops.

#### Break - exits loop immediately

```typescript
for (let i = 0; i < 10; i++) {
    if (i === 5) break;
    console.log(i);
}
```

#### Continue - skips to next iteration

```typescript
for (let i = 0; i < 10; i++) {
    if (i % 2 === 0) continue;
    console.log(i);
}
```

#### Break in while loop

```typescript
let i: number = 0;
while (true) {
    if (i === 5) break;
    console.log(i);
    i++;
}
```

#### Continue in while loop

```typescript
i = 0;
while (i < 10) {
    i++;
    if (i % 2 === 0) continue;
    console.log(i);
}
```

#### Break in for-of loop

```typescript
let numbers: number[] = [1, 2, 3, 4, 5];
for (let num of numbers) {
    if (num === 3) break;
    console.log(num);
}
```

#### Continue in for-of loop

```typescript
for (let num of numbers) {
    if (num % 2 === 0) continue;
    console.log(num);
}
```

#### Break in nested loops (only breaks inner loop)

```typescript
for (let i = 0; i < 3; i++) {
    for (let j = 0; j < 3; j++) {
        if (j === 2) break;
        console.log(`(${i},${j})`);
    }
}
```

#### Labeled break (breaks outer loop)

```typescript
outer: for (let i = 0; i < 3; i++) {
    for (let j = 0; j < 3; j++) {
        if (i === 1 && j === 1) break outer;
        console.log(`(${i},${j})`);
    }
}
```

#### Labeled continue (continues outer loop)

```typescript
outer: for (let i = 0; i < 3; i++) {
    for (let j = 0; j < 3; j++) {
        if (j === 1) continue outer;
        console.log(`(${i},${j})`);
    }
}
```

#### Break in switch

```typescript
switch (value) {
    case 1:
        console.log("One");
        break;
    case 2:
        console.log("Two");
        break;
}
```

#### forEach with break/continue alternatives

```typescript
numbers.forEach(num => {
    if (num % 2 === 0) return;
    console.log(num);
});
```

#### Use for-of instead for break/continue

```typescript
for (let num of numbers) {
    if (num === 3) break;
    if (num % 2 === 0) continue;
    console.log(num);
}
```

#### some() returns true and stops on first match (like break)

```typescript
let found = numbers.some(num => {
    console.log(num);
    return num === 3;
});
```

#### every() returns false and stops on first false (like break)

```typescript
let allPositive = numbers.every(num => {
    console.log(num);
    return num > 0;
});
```

## Comparison Summary

| Feature | C++ | Python | Julia | TypeScript |
|---------|-----|--------|-------|------------|
| **If/Else Syntax** | Braces `{}` | Indentation | `end` keyword | Braces `{}` |
| **Ternary** | `? :` | `if-else` inline | `? :` | `? :` |
| **For Loop** | Traditional & range-based | `for-in` only | `for-in` with ranges | Traditional & `for-of` |
| **While Loop** | `while`, `do-while` | `while` only | `while` only | `while`, `do-while` |
| **Switch/Match** | `switch` (limited) | `match-case` (3.10+) | If-elseif chains | `switch` |
| **Pattern Matching** | No | Yes (3.10+) | Multiple dispatch | No |
| **Loop Else** | No | Yes | No | No |
| **Labeled Break** | No (use `goto`) | No | `@goto` | Yes |
| **Break/Continue** | Yes | Yes | Yes | Yes |

## Key Differences

### C++
- **Braces required** for blocks (optional for single statements)
- **Traditional for loop** with three parts
- **Range-based for** for modern iteration
- **Do-while** executes at least once
- **Switch** limited to integral types
- **goto** available but discouraged

### Python
- **Indentation-based** syntax (no braces)
- **No traditional for loop** - uses `for-in` with `range()`
- **No do-while** - simulate with `while True` + `break`
- **match-case** (3.10+) with powerful pattern matching
- **Loop else** clause - executes if no `break`
- **Walrus operator** (`:=`) for assignment in conditions

### Julia
- **end keyword** closes all blocks
- **Multiple assignment forms** (`for i in` or `for i =`)
- **No built-in switch** - use if-elseif or dictionaries
- **Multiple dispatch** instead of pattern matching
- **Compact nested loop** syntax: `for i in 1:3, j in 1:3`
- **@goto and @label** for advanced control flow

### TypeScript
- **JavaScript-based** syntax with type annotations
- **Both traditional and modern** loop styles
- **for-of** for values, **for-in** for keys/indices
- **Labeled statements** for breaking outer loops
- **No loop else** clause
- **Functional alternatives** (map, filter, forEach)
- **async/await** compatible loops