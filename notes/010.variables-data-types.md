### Variables & Data Types

## Common Data Types

| Type | C++ | Python | Julia | TypeScript |
|------|-----|--------|-------|------------|
| **Integer** | `int`, `long` | `int` | `Int64`, `Int32` | `number` |
| **Float** | `float`, `double` | `float` | `Float64`, `Float32` | `number` |
| **String** | `string` | `str` | `String` | `string` |
| **Boolean** | `bool` | `bool` | `Bool` | `boolean` |
| **Null/None** | `nullptr` | `None` | `nothing` | `null`, `undefined` |

## Type Conversion Examples

# Variable Declaration & Data Types Comparison

## Basic Variable Declaration

### C++
```cpp
// Explicit type required
int x = 5;
float y = 3.14;
string name = "John";
bool isActive = true;

// Type inference (C++11+)
auto z = 10;        // int
auto pi = 3.14;     // double
```

### Python
```python
# Dynamic typing - no type declaration
x = 5              # int
y = 3.14           # float
name = "John"      # str
is_active = True   # bool

# Type hints (optional, Python 3.5+)
x: int = 5
y: float = 3.14
name: str = "John"
```

### Julia
```julia
# Dynamic typing - no type required
x = 5              # Int64
y = 3.14           # Float64
name = "John"      # String
is_active = true   # Bool

# Explicit type annotation (optional)
x::Int64 = 5
y::Float64 = 3.14
name::String = "John"
```

### TypeScript
```typescript
// Explicit type annotation
let x: number = 5;
let y: number = 3.14;
let name: string = "John";
let isActive: boolean = true;

// Type inference
let z = 10;        // number (inferred)
let pi = 3.14;     // number (inferred)

// const for immutable
const MAX = 100;
```

## Key Differences

### C++
- **Strongly typed** - must declare type
- **Compiled** - type errors caught at compile time
- **Manual memory management** (unless using smart pointers)
- `auto` keyword allows type inference

### Python
- **Dynamically typed** - type determined at runtime
- **Interpreted** - flexible but can have runtime type errors
- **Type hints** are optional and not enforced at runtime
- Variable can change type: `x = 5` then `x = "hello"` is valid

### Julia
- **Dynamically typed** but with **optional type annotations**
- **JIT compiled** - performance close to C++
- Type annotations help with performance optimization
- Strong focus on numerical computing types
- Multiple dispatch based on types

### TypeScript
- **Statically typed** superset of JavaScript
- **Transpiled** to JavaScript
- Type checking at compile/transpile time
- `any` type for dynamic behavior
- Strict null checking available

## Type Casting

### C++ (Multiple Cast Types)
```cpp
// C-style cast (avoid in modern C++)
int x = 5;
double y = (double)x;

// static_cast (most common, compile-time)
double z = static_cast<double>(x);
int a = static_cast<int>(3.14);     // 3

// dynamic_cast (runtime type checking, for polymorphism)
Base* basePtr = new Derived();
Derived* derivedPtr = dynamic_cast<Derived*>(basePtr);
if (derivedPtr != nullptr) {
    // Safe to use
}

// const_cast (remove const qualifier)
const int* constPtr = &x;
int* modifiablePtr = const_cast<int*>(constPtr);

// reinterpret_cast (dangerous, low-level)
int num = 65;
char* charPtr = reinterpret_cast<char*>(&num);

// Implicit conversion
int i = 42;
double d = i;       // Implicit conversion OK

// Explicit constructor
std::string str = std::string("hello");
```

### Python (Duck Typing + Explicit Conversion)
```python
# Explicit type conversion
x = 5
y = float(x)        # 5.0
z = str(x)          # "5"
a = int(3.14)       # 3
b = bool(0)         # False
c = list("abc")     # ['a', 'b', 'c']

# No type casting needed (duck typing)
def process(value):
    return value * 2

process(5)          # 10
process("hi")       # "hihi"
process([1, 2])     # [1, 2, 1, 2]

# Type checking (runtime)
x = 5
if isinstance(x, int):
    print("It's an integer")

# Type assertion (for type checkers, not runtime)
from typing import cast
x: object = "hello"
y: str = cast(str, x)   # Just tells type checker

# Convert between collections
my_list = [1, 2, 3]
my_tuple = tuple(my_list)
my_set = set(my_list)
my_dict = dict(zip(['a', 'b'], [1, 2]))
```

### Julia (Convert vs Cast)
```cpp
// convert() - safe conversion
x = 5
y = convert(Float64, x)     # 5.0
z = convert(Int, 3.0)       # 3
# convert(Int, 3.5)         # InexactError!

// Type assertion (::)
x = 5
y = x::Int64                # Asserts x is Int64
# x::Float64                # TypeError!

// Promotion (automatic)
x = 1 + 2.0                 # Float64: 3.0 (promotes Int to Float)

// Explicit constructors
x = Float64(5)              # 5.0
y = Int64(3.0)              # 3
z = String([72, 105])       # "Hi"

// parse() for strings
x = parse(Int, "123")       # 123
y = parse(Float64, "3.14")  # 3.14

// Type checking
x = 5
if x isa Int64
    println("It's an Int64")
end

// typeof() for type inspection
typeof(5)                   # Int64
typeof(3.14)                # Float64

// Union types (can be multiple types)
x::Union{Int, String} = 5
x = "hello"                 # Also valid

// Abstract types
function process(x::Real)   # Accepts any real number
    return x * 2
end
```

### TypeScript (Type Assertions)
```typescript
// Type assertion (doesn't change runtime value)
let value: any = "hello";
let strLength: number = (value as string).length;
let strLength2: number = (<string>value).length;  // Alternative syntax

// Type casting for primitives (JavaScript conversion)
let x: number = 5;
let y: string = x.toString();
let z: string = String(x);

let str: string = "123";
let num: number = Number(str);      // 123
let num2: number = parseInt(str);   // 123
let num3: number = parseFloat("3.14");  // 3.14

// Boolean conversion
let bool1: boolean = Boolean(0);        // false
let bool2: boolean = Boolean("text");   // true

// Type guards (runtime checking)
function process(value: string | number) {
    if (typeof value === "string") {
        return value.toUpperCase();    // TS knows it's string
    } else {
        return value * 2;              // TS knows it's number
    }
}

// instanceof (for classes)
class Dog {}
class Cat {}

function identify(animal: Dog | Cat) {
    if (animal instanceof Dog) {
        // animal is Dog here
    }
}

// User-defined type guards
function isString(value: any): value is string {
    return typeof value === "string";
}

// Non-null assertion
let maybeString: string | null = "hello";
let length: number = maybeString!.length;  // Asserts not null

// const assertions (literal type)
let x = "hello" as const;       // Type is "hello", not string
let arr = [1, 2] as const;      // Readonly tuple [1, 2]

// satisfies operator (type checking without widening)
const config = {
    url: "https://api.com",
    timeout: 5000
} satisfies Record<string, string | number>;
```

## Casting Comparison Summary

| Feature | C++ | Python | Julia | TypeScript |
|---------|-----|--------|-------|------------|
| **Safety Level** | Multiple levels | Safe (duck typing) | Safe with convert | Compile-time only |
| **Main Method** | `static_cast<T>()` | `type(value)` | `convert(T, x)` | `as` or `<type>` |
| **Runtime Check** | `dynamic_cast` | `isinstance()` | `isa` | `typeof`, `instanceof` |
| **String to Number** | `stoi()`, `stod()` | `int()`, `float()` | `parse(T, str)` | `Number()`, `parseInt()` |
| **Number to String** | `to_string()` | `str()` | `string()` | `toString()`, `String()` |
| **Type Assertion** | Templates | Type hints | `::` operator | `as`, `!` |

## Key Differences

### C++
- **Most explicit** - many cast types for different scenarios
- **Compile-time safety** with `static_cast`
- **Runtime safety** with `dynamic_cast`
- **Fine-grained control** over memory and access

### Python
- **No real casting** - uses duck typing
- **Type conversion** instead of casting
- **Runtime type checking** with `isinstance()`
- **Type hints don't enforce**, just for tooling

### Julia
- **`convert()` for safe conversion** - errors if impossible
- **Type assertions** with `::` for optimization
- **Multiple dispatch** based on types
- **Performance-focused** type system

### TypeScript
- **Compile-time only** - no runtime effect
- **Type assertions** tell compiler, not runtime
- **JavaScript conversion** methods for actual casting
- **Type guards** for runtime checking

