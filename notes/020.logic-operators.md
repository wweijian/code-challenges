# Operators in C++, Python, Julia, and TypeScript

## C++

### Math operators
(`+`, `-`, `*`, `/`, `%`) work on numeric types. Integer division truncates (`5/2 = 2`). Use modulo `%` for remainders.
```cpp
int a = 10, b = 3;
int sum = a + b;        // 13
int diff = a - b;       // 7
int product = a * b;    // 30
int quotient = a / b;   // 3 (truncates)
int remainder = a % b;  // 1
```

### Increment/decrement
`++` and `--` work as prefix (`++x`) or postfix (`x++`). Prefix returns new value, postfix returns old value.
```cpp
int x = 5;
int y = ++x;  // x = 6, y = 6 (prefix)
int z = x++;  // x = 7, z = 6 (postfix)
```

### Compound assignment
`+=`, `-=`, `*=`, `/=`, `%=` modify variable in place: `x += 5` is `x = x + 5`.
```cpp
int x = 10;
x += 5;   // x = 15
x -= 3;   // x = 12
x *= 2;   // x = 24
x /= 4;   // x = 6
x %= 4;   // x = 2
```

### Comparison operators
(`==`, `!=`, `<`, `>`, `<=`, `>=`) return boolean values. `==` compares values; for pointers, use carefully as it compares addresses. String comparison works with `std::string` but C-strings need `strcmp()`.
```cpp
int a = 5, b = 10;
bool equal = (a == b);      // false
bool notEqual = (a != b);   // true
bool less = (a < b);        // true
bool greater = (a > b);     // false

std::string s1 = "hello", s2 = "world";
bool strEqual = (s1 == s2); // false
```

### Logic operators
`&&` (and), `||` (or), `!` (not). They short-circuit. Work on any type that converts to bool (0 is false, non-zero is true).
```cpp
bool a = true, b = false;
bool andResult = a && b;    // false
bool orResult = a || b;     // true
bool notResult = !a;        // false

int x = 0;
if (x != 0 && 10 / x > 2) {
    // Safe from division by zero
}
```

---

## Python

### Math operators
Include the standard set plus `**` for exponentiation and `//` for floor division. Division `/` always returns float even with integers (`5/2 = 2.5`). Works on many types—`+` concatenates strings/lists, `*` repeats them.
```python
a, b = 10, 3
sum_val = a + b        # 13
quotient = a / b       # 3.3333... (float)
floor_div = a // b     # 3 (floor division)
power = a ** b         # 1000
remainder = a % b      # 1

text = "hi" + " there"    # "hi there"
repeat = "ha" * 3         # "hahaha"
combined = [1, 2] + [3]   # [1, 2, 3]
```

### Compound assignment
`+=`, `-=`, `*=`, `/=`, `//=`, `%=`, `**=` modify variable in place. Note: Python has no `++` or `--` operators—use `x += 1` instead.
```python
x = 10
x += 5    # x = 15
x -= 3    # x = 12
x *= 2    # x = 24
x //= 4   # x = 6
x **= 2   # x = 36
x += 1    # No x++ in Python!
```

### Comparison operators
Use the same symbols but can be chained: `x < y < z` works naturally. `==` compares values; `is` compares object identity. Works on most types including strings (lexicographic comparison).
```python
a, b, c = 5, 10, 15
equal = (a == b)           # False
chained = (a < b < c)      # True (can chain!)

list1 = [1, 2, 3]
list2 = [1, 2, 3]
list3 = list1
print(list1 == list2)      # True (same values)
print(list1 is list2)      # False (different objects)
print(list1 is list3)      # True (same object)
```

### Logic operators
`and`, `or`, `not` (words, not symbols). They short-circuit and return the actual value that determined the result, not just True/False: `5 or 0` returns `5`. Any object can be used in boolean context (empty containers are falsy).
```python
a, b = True, False
and_result = a and b       # False
or_result = a or b         # True
not_result = not a         # False

result1 = 5 or 0           # 5
result2 = "" or "default"  # "default"
result3 = [1, 2] and "yes" # "yes"

if not []:                 # True (empty list is falsy)
    print("Empty!")
```

---

## Julia

### Math operators
Similar to Python, including `^` for exponentiation and `÷` (or `div()`) for integer division. Very flexible—operators are just functions, so `+(1,2)` equals `1+2`. Supports Unicode operators like `∈` for set membership.
```julia
a, b = 10, 3
sum_val = a + b        # 13
quotient = a / b       # 3.3333... (float)
int_div = a ÷ b        # 3 (or div(a, b))
power = a ^ b          # 1000
remainder = a % b      # 1

result = +(1, 2, 3)    # 6 (same as 1 + 2 + 3)

in_set = 2 ∈ [1, 2, 3] # true
```

### Compound assignment
`+=`, `-=`, `*=`, `/=`, `÷=`, `%=`, `^=` modify variable in place. Julia has no `++` or `--` operators—use `x += 1` instead.
```julia
x = 10
x += 5    # x = 15
x -= 3    # x = 12
x *= 2    # x = 24
x ÷= 4    # x = 6
x ^= 2    # x = 36
x += 1    # No x++ in Julia!
```

### Comparison operators
Support chaining like Python: `1 < 2 < 3`. `==` compares values, `===` checks if objects are identical. Broadcasting with `.==` compares arrays element-wise: `[1,2] .== [1,3]` returns `[true, false]`.
```julia
a, b, c = 5, 10, 15
equal = (a == b)           # false
chained = (a < b < c)      # true (can chain!)

arr1 = [1, 2, 3]
arr2 = [1, 2, 4]
element_eq = arr1 .== arr2 # [true, true, false]

x = [1, 2, 3]
y = [1, 2, 3]
z = x
println(x == y)            # true (same values)
println(x === y)           # false (different objects)
println(x === z)           # true (same object)
```

### Logic operators
`&&` (and), `||` (or), `!` (not), similar to C++. Short-circuit evaluation. For element-wise array operations, use `&`, `|` without short-circuiting, or broadcast: `.&&`. Only `true`/`false` are boolean; numbers don't auto-convert.
```julia
a, b = true, false
and_result = a && b        # false
or_result = a || b         # true
not_result = !a            # false

arr1 = [true, false, true]
arr2 = [true, true, false]
bitwise_and = arr1 .& arr2 # [true, false, false]

x = 0
if x != 0 && 10 / x > 2
    println("Safe!")
end
```

---

## TypeScript

### Math operators
Work like JavaScript: `+`, `-`, `*`, `/`, `%`, plus `**` for exponentiation. Division always returns numbers with decimals. `+` also concatenates strings, and type coercion can be tricky: `"5" + 3 = "53"` but `"5" - 3 = 2`.
```typescript
let a: number = 10, b: number = 3;
let sum: number = a + b;        // 13
let quotient: number = a / b;   // 3.3333... (always float)
let power: number = a ** b;     // 1000
let remainder: number = a % b;  // 1

let concat = "5" + 3;           // "53" (string concatenation)
let subtract = "5" - 3;         // 2 (coerced to number)
let multiply = "5" * 3;         // 15 (coerced to number)
```

### Increment/decrement
`++` and `--` work as prefix (`++x`) or postfix (`x++`). Prefix returns new value, postfix returns old value.
```typescript
let x: number = 5;
let y: number = ++x;  // x = 6, y = 6 (prefix)
let z: number = x++;  // x = 7, z = 6 (postfix)
```

### Compound assignment
`+=`, `-=`, `*=`, `/=`, `%=`, `**=` modify variable in place: `x += 5` is `x = x + 5`.
```typescript
let x: number = 10;
x += 5;   // x = 15
x -= 3;   // x = 12
x *= 2;   // x = 24
x /= 4;   // x = 6
x %= 4;   // x = 2
x **= 2;  // x = 4
```

### Comparison operators
Have two versions: loose (`==`, `!=`) with type coercion, and strict (`===`, `!==`) without. Always prefer strict equality: `5 === "5"` is false, but `5 == "5"` is true due to coercion. TypeScript's type system helps catch comparison errors at compile time.
```typescript
let a: number = 5;
let b: string = "5";

console.log(a == b);        // true (coercion)
console.log(a != b);        // false

console.log(a === b);       // false (different types)
console.log(a !== b);       // true

let x: number = 10, y: number = 20;
console.log(x < y);         // true
console.log(x >= y);        // false
```

### Logic operators
`&&`, `||`, `!`. Short-circuit and return the actual value: `"hello" || "world"` returns `"hello"`. Falsy values are `false`, `0`, `""`, `null`, `undefined`, `NaN`. The nullish coalescing operator `??` only treats `null`/`undefined` as falsy.
```typescript
let a: boolean = true, b: boolean = false;
let andResult: boolean = a && b;    // false
let orResult: boolean = a || b;     // true
let notResult: boolean = !a;        // false

let value1 = "hello" || "world";    // "hello"
let value2 = 0 || 42;               // 42
let value3 = "" || "default";       // "default"

let nullValue: string | null = null;
let result1 = nullValue ?? "default";  // "default"
let result2 = 0 ?? "default";          // 0 (0 is not null/undefined)

if (!0 && !"" && !null && !undefined) {
    console.log("All falsy!");
}
```

---

## Glossary

**Identity comparison:** checks if two variables refer to the exact same object in memory, not just whether they have the same value.
```python
a = [1, 2, 3]
b = [1, 2, 3]
c = a

a == b  # True (same contents)
a is b  # False (different objects in memory)
a is c  # True (c points to the same object as a)
```

**Short Circuit:** exits when the first check already satisfies the condition

---

## Summary Table

| Feature | C++ | Python | Julia | TypeScript |
|---------|-----|--------|-------|------------|
| **Division** | `/` | `/` (always float) | `/` (returns float) | `/` |
| **Integer Division** | `/` truncates (int÷int) | `//` floors | `÷` or `div()` | `/` returns decimal |
| **Exponentiation** | `pow()` function | `**` | `^` | `**` |
| **Modulo** | `%` | `%` | `%` or `mod()` | `%` |
| **Increment/Decrement** | `++`, `--` | ❌ (use `+= 1`) | ❌ (use `+= 1`) | `++`, `--` |
| **Compound Assignment** | `+=`, `-=`, `*=`, `/=`, `%=` | `+=`, `-=`, `*=`, `/=`, `//=`, `**=` | `+=`, `-=`, `*=`, `/=`, `^=` | `+=`, `-=`, `*=`, `/=`, `%=`, `**=` |
| **Equality** | `==` | `==` (value), `is` (identity) | `==` (value), `===` (identity) | `===` (strict), `==` (loose) |
| **Logic AND** | `&&` | `and` | `&&` | `&&` |
| **Logic OR** | `\|\|` | `or` | `\|\|` | `\|\|` |
| **Logic NOT** | `!` | `not` | `!` | `!` |
| **Short-circuit** | Yes | Yes | Yes | Yes |
| **Comparison Chaining** | No | Yes (`x < y < z`) | Yes (`x < y < z`) | No |
| **Type Coercion** | Numeric promotions | Minimal | Type-stable | Extensive (avoid with `===`) |
| **Truthy/Falsy** | 0 is false, non-zero true | Empty = falsy | Only `true`/`false` | `0`, `""`, `null`, `undefined`, `NaN` = falsy |