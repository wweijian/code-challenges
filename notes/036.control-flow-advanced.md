### Iteration Syntaxes for Collections

## Iterating Through Arrays/Lists

### C++

#### By value (copy)

```cpp
std::vector<int> numbers = {1, 2, 3, 4, 5};
for (auto num : numbers) {
    std::cout << num << " ";
}
```

#### By reference (can modify)

```cpp
std::vector<int> numbers = {1, 2, 3, 4, 5};
for (auto& num : numbers) {
    num *= 2;
}
```

#### By const reference (read-only, efficient)

```cpp
std::vector<int> numbers = {1, 2, 3, 4, 5};
for (const auto& num : numbers) {
    std::cout << num << " ";
}
```

#### With explicit type

```cpp
std::vector<int> numbers = {1, 2, 3, 4, 5};
for (int num : numbers) {
    std::cout << num << " ";
}
```

#### Forward iteration with iterators

```cpp
std::vector<int> numbers = {1, 2, 3, 4, 5};
for (auto it = numbers.begin(); it != numbers.end(); ++it) {
    std::cout << *it << " ";
}
```

#### Const iterator

```cpp
std::vector<int> numbers = {1, 2, 3, 4, 5};
for (auto it = numbers.cbegin(); it != numbers.cend(); ++it) {
    std::cout << *it << " ";
}
```

#### Reverse iteration with iterators

```cpp
std::vector<int> numbers = {1, 2, 3, 4, 5};
for (auto it = numbers.rbegin(); it != numbers.rend(); ++it) {
    std::cout << *it << " ";
}
```

#### Const reverse iterator

```cpp
std::vector<int> numbers = {1, 2, 3, 4, 5};
for (auto it = numbers.crbegin(); it != numbers.crend(); ++it) {
    std::cout << *it << " ";
}
```

#### Index-based loop

```cpp
std::vector<int> numbers = {1, 2, 3, 4, 5};
for (size_t i = 0; i < numbers.size(); ++i) {
    std::cout << numbers[i] << " ";
}
```

#### Reverse index-based loop

```cpp
std::vector<int> numbers = {1, 2, 3, 4, 5};
for (int i = numbers.size() - 1; i >= 0; --i) {
    std::cout << numbers[i] << " ";
}
```

#### Index-based with step

```cpp
std::vector<int> numbers = {1, 2, 3, 4, 5};
for (size_t i = 0; i < numbers.size(); i += 2) {
    std::cout << numbers[i] << " ";
}
```

#### std::for_each

```cpp
#include <algorithm>

std::vector<int> numbers = {1, 2, 3, 4, 5};
std::for_each(numbers.begin(), numbers.end(), [](int num) {
    std::cout << num << " ";
});
```

#### std::for_each with index tracking

```cpp
std::vector<int> numbers = {1, 2, 3, 4, 5};
int index = 0;
std::for_each(numbers.begin(), numbers.end(), [&index](int num) {
    std::cout << "Index " << index++ << ": " << num << std::endl;
});
```

#### std::for_each modifying elements

```cpp
std::vector<int> numbers = {1, 2, 3, 4, 5};
std::for_each(numbers.begin(), numbers.end(), [](int& num) {
    num *= 2;
});
```

### Python

#### Iterate over elements

```python
numbers = [1, 2, 3, 4, 5]
for num in numbers:
    print(num, end=" ")
```

#### Modify list with comprehension

```python
numbers = [1, 2, 3, 4, 5]
numbers = [num * 2 for num in numbers]
```

#### enumerate() - index and value

```python
numbers = [1, 2, 3, 4, 5]
for i, num in enumerate(numbers):
    print(f"Index {i}: {num}")
```

#### enumerate() with custom start

```python
numbers = [1, 2, 3, 4, 5]
for i, num in enumerate(numbers, start=1):
    print(f"Item {i}: {num}")
```

#### Modify with enumerate()

```python
numbers = [1, 2, 3, 4, 5]
for i, num in enumerate(numbers):
    numbers[i] = num * 2
```

#### Reverse iteration with reversed()

```python
numbers = [1, 2, 3, 4, 5]
for num in reversed(numbers):
    print(num, end=" ")
```

#### Reversed with enumerate()

```python
numbers = [1, 2, 3, 4, 5]
for i, num in enumerate(reversed(numbers)):
    print(f"{i}: {num}")
```

#### Index-based with range()

```python
numbers = [1, 2, 3, 4, 5]
for i in range(len(numbers)):
    print(numbers[i], end=" ")
```

#### Reverse index-based

```python
numbers = [1, 2, 3, 4, 5]
for i in range(len(numbers) - 1, -1, -1):
    print(numbers[i], end=" ")
```

#### Index-based with step

```python
numbers = [1, 2, 3, 4, 5]
for i in range(0, len(numbers), 2):
    print(numbers[i], end=" ")
```

#### Manual iterator with next()

```python
numbers = [1, 2, 3, 4, 5]
it = iter(numbers)
while True:
    try:
        num = next(it)
        print(num, end=" ")
    except StopIteration:
        break
```

### Julia

#### Iterate with in

```julia
numbers = [1, 2, 3, 4, 5]
for num in numbers
    print("$num ")
end
```

#### Iterate with =

```julia
numbers = [1, 2, 3, 4, 5]
for num = numbers
    print("$num ")
end
```

#### Modify with eachindex()

```julia
numbers = [1, 2, 3, 4, 5]
for i in eachindex(numbers)
    numbers[i] *= 2
end
```

#### enumerate() - index and value

```julia
numbers = [1, 2, 3, 4, 5]
for (i, num) in enumerate(numbers)
    println("Index $i: $num")
end
```

#### Unpack with enumerate()

```julia
numbers = [1, 2, 3, 4, 5]
for (idx, val) in enumerate(numbers)
    println("$idx -> $val")
end
```

#### Iterate with eachindex()

```julia
numbers = [1, 2, 3, 4, 5]
for i in eachindex(numbers)
    println("Index $i: $(numbers[i])")
end
```

#### Reverse with reverse()

```julia
numbers = [1, 2, 3, 4, 5]
for num in reverse(numbers)
    print("$num ")
end
```

#### Reverse with index range

```julia
numbers = [1, 2, 3, 4, 5]
for i in length(numbers):-1:1
    print("$(numbers[i]) ")
end
```

#### Reverse with Iterators.reverse()

```julia
using Iterators
numbers = [1, 2, 3, 4, 5]
for num in Iterators.reverse(numbers)
    print("$num ")
end
```

#### pairs() - index and value

```julia
numbers = [1, 2, 3, 4, 5]
for (idx, val) in pairs(numbers)
    println("$idx => $val")
end
```

### TypeScript

#### for-of loop (values)

```typescript
let numbers: number[] = [1, 2, 3, 4, 5];
for (let num of numbers) {
    console.log(num);
}
```

#### for-in loop (indices as strings)

```typescript
let numbers: number[] = [1, 2, 3, 4, 5];
for (let i in numbers) {
    console.log(`Index ${i}: ${numbers[i]}`);
}
```

#### for-in with number conversion

```typescript
let numbers: number[] = [1, 2, 3, 4, 5];
for (let i in numbers) {
    let index = Number(i);
    console.log(`Index ${index}: ${numbers[index]}`);
}
```

#### entries() - index and value

```typescript
let numbers: number[] = [1, 2, 3, 4, 5];
for (let [i, num] of numbers.entries()) {
    console.log(`Index ${i}: ${num}`);
}
```

#### entries() with destructuring

```typescript
let numbers: number[] = [1, 2, 3, 4, 5];
for (let [index, value] of numbers.entries()) {
    console.log(`${index} -> ${value}`);
}
```

#### forEach() basic

```typescript
let numbers: number[] = [1, 2, 3, 4, 5];
numbers.forEach(num => {
    console.log(num);
});
```

#### forEach() with index and array

```typescript
let numbers: number[] = [1, 2, 3, 4, 5];
numbers.forEach((num, i, arr) => {
    console.log(`Index ${i}: ${num} of ${arr.length}`);
});
```

#### Traditional for loop

```typescript
let numbers: number[] = [1, 2, 3, 4, 5];
for (let i = 0; i < numbers.length; i++) {
    console.log(numbers[i]);
}
```

#### Reverse traditional for loop

```typescript
let numbers: number[] = [1, 2, 3, 4, 5];
for (let i = numbers.length - 1; i >= 0; i--) {
    console.log(numbers[i]);
}
```

#### Traditional for loop with step

```typescript
let numbers: number[] = [1, 2, 3, 4, 5];
for (let i = 0; i < numbers.length; i += 2) {
    console.log(numbers[i]);
}
```

#### Modify with traditional for loop

```typescript
let numbers: number[] = [1, 2, 3, 4, 5];
for (let i = 0; i < numbers.length; i++) {
    numbers[i] *= 2;
}
```

#### Manual iterator with Symbol.iterator

```typescript
let numbers: number[] = [1, 2, 3, 4, 5];
let iterator = numbers[Symbol.iterator]();
let result = iterator.next();
while (!result.done) {
    console.log(result.value);
    result = iterator.next();
}
```

#### Iterate with values()

```typescript
let numbers: number[] = [1, 2, 3, 4, 5];
for (let num of numbers.values()) {
    console.log(num);
}
```

## Iterating Through Strings

### C++

#### Range-based for over characters

```cpp
std::string word = "hello";
for (char c : word) {
    std::cout << c << " ";
}
```

#### Range-based for with reference

```cpp
std::string word = "hello";
for (char& c : word) {
    c = toupper(c);
}
```

#### Range-based for with const reference

```cpp
std::string word = "hello";
for (const char& c : word) {
    std::cout << c << " ";
}
```

#### Range-based for with auto

```cpp
std::string word = "hello";
for (auto letter : word) {
    std::cout << letter << " ";
}
```

#### Forward iteration with iterators

```cpp
std::string word = "hello";
for (auto it = word.begin(); it != word.end(); ++it) {
    std::cout << *it << " ";
}
```

#### Reverse iteration with iterators

```cpp
std::string word = "hello";
for (auto it = word.rbegin(); it != word.rend(); ++it) {
    std::cout << *it << " ";
}
```

#### Modify with iterator

```cpp
std::string word = "hello";
for (auto it = word.begin(); it != word.end(); ++it) {
    *it = toupper(*it);
}
```

#### Index-based iteration

```cpp
std::string word = "hello";
for (size_t i = 0; i < word.length(); ++i) {
    std::cout << word[i] << " ";
}
```

#### Reverse index-based

```cpp
std::string word = "hello";
for (int i = word.length() - 1; i >= 0; --i) {
    std::cout << word[i] << " ";
}
```

#### Index-based with at()

```cpp
std::string word = "hello";
for (size_t i = 0; i < word.size(); ++i) {
    std::cout << word.at(i) << " ";
}
```

### Python

#### Iterate over characters

```python
word = "hello"
for char in word:
    print(char, end=" ")
```

#### Create uppercase with comprehension

```python
word = "hello"
upper_word = ''.join(c.upper() for c in word)
```

#### enumerate() with strings

```python
word = "hello"
for i, char in enumerate(word):
    print(f"Index {i}: {char}")
```

#### enumerate() starting from 1

```python
word = "hello"
for i, char in enumerate(word, start=1):
    print(f"Position {i}: {char}")
```

#### Reverse with reversed()

```python
word = "hello"
for char in reversed(word):
    print(char, end=" ")
```

#### Reverse with slicing

```python
word = "hello"
for char in word[::-1]:
    print(char, end=" ")
```

#### Index-based with range()

```python
word = "hello"
for i in range(len(word)):
    print(word[i], end=" ")
```

#### Reverse index-based

```python
word = "hello"
for i in range(len(word) - 1, -1, -1):
    print(word[i], end=" ")
```

#### Index-based with step

```python
word = "hello"
for i in range(0, len(word), 2):
    print(word[i], end=" ")
```

### Julia

#### Iterate over characters

```julia
word = "hello"
for char in word
    print("$char ")
end
```

#### enumerate() with strings

```julia
word = "hello"
for (i, char) in enumerate(word)
    println("Index $i: $char")
end
```

#### eachindex() for valid indices

```julia
word = "hello"
for i in eachindex(word)
    println("Index $i: $(word[i])")
end
```

#### eachindex() with Unicode strings

```julia
unicode_word = "hÃ©llo"
for i in eachindex(unicode_word)
    println("$i: $(unicode_word[i])")
end
```

#### Reverse with reverse()

```julia
word = "hello"
for char in reverse(word)
    print("$char ")
end
```

#### Reverse with index range

```julia
word = "hello"
for i in length(word):-1:1
    print("$(word[i]) ")
end
```

### TypeScript

#### for-of over characters

```typescript
let word: string = "hello";
for (let char of word) {
    console.log(char);
}
```

#### Build uppercase string

```typescript
let word: string = "hello";
let upper = '';
for (let char of word) {
    upper += char.toUpperCase();
}
```

#### for-in over indices

```typescript
let word: string = "hello";
for (let i in word) {
    console.log(`Index ${i}: ${word[i]}`);
}
```

#### for-in with number conversion

```typescript
let word: string = "hello";
for (let i in word) {
    let index = Number(i);
    console.log(`${index}: ${word[index]}`);
}
```

#### Traditional for loop

```typescript
let word: string = "hello";
for (let i = 0; i < word.length; i++) {
    console.log(word[i]);
}
```

#### Reverse traditional for loop

```typescript
let word: string = "hello";
for (let i = word.length - 1; i >= 0; i--) {
    console.log(word[i]);
}
```

#### charAt() method

```typescript
let word: string = "hello";
for (let i = 0; i < word.length; i++) {
    console.log(word.charAt(i));
}
```

#### Spread to array with forEach()

```typescript
let word: string = "hello";
[...word].forEach(char => {
    console.log(char);
});
```

#### Spread with index

```typescript
let word: string = "hello";
[...word].forEach((char, i) => {
    console.log(`${i}: ${char}`);
});
```

#### split() to array

```typescript
let word: string = "hello";
word.split('').forEach(char => {
    console.log(char);
});
```

## Iterating Through Objects/Maps/Dictionaries

### C++

#### Range-based for with pairs

```cpp
#include <map>

std::map<std::string, int> ages = {
    {"Alice", 25},
    {"Bob", 30},
    {"Charlie", 35}
};

for (const auto& pair : ages) {
    std::cout << pair.first << ": " << pair.second << std::endl;
}
```

#### Structured binding (C++17)

```cpp
std::map<std::string, int> ages = {
    {"Alice", 25},
    {"Bob", 30},
    {"Charlie", 35}
};

for (const auto& [key, value] : ages) {
    std::cout << key << ": " << value << std::endl;
}
```

#### Structured binding with reference (modify values)

```cpp
std::map<std::string, int> ages = {
    {"Alice", 25},
    {"Bob", 30}
};

for (auto& [key, value] : ages) {
    value += 1;
}
```

#### Forward iteration with iterators

```cpp
std::map<std::string, int> ages = {{"Alice", 25}, {"Bob", 30}};
for (auto it = ages.begin(); it != ages.end(); ++it) {
    std::cout << it->first << ": " << it->second << std::endl;
}
```

#### Reverse iteration with iterators

```cpp
std::map<std::string, int> ages = {{"Alice", 25}, {"Bob", 30}};
for (auto it = ages.rbegin(); it != ages.rend(); ++it) {
    std::cout << it->first << ": " << it->second << std::endl;
}
```

#### unordered_map iteration

```cpp
#include <unordered_map>

std::unordered_map<std::string, int> ages = {{"Alice", 25}, {"Bob", 30}};
for (const auto& [key, value] : ages) {
    std::cout << key << ": " << value << std::endl;
}
```

### Python

#### Iterate over keys (default)

```python
ages = {"Alice": 25, "Bob": 30, "Charlie": 35}
for key in ages:
    print(f"{key}: {ages[key]}")
```

#### Explicit keys()

```python
ages = {"Alice": 25, "Bob": 30, "Charlie": 35}
for key in ages.keys():
    print(key)
```

#### items() - key-value pairs

```python
ages = {"Alice": 25, "Bob": 30, "Charlie": 35}
for key, value in ages.items():
    print(f"{key}: {value}")
```

#### items() with unpacking

```python
ages = {"Alice": 25, "Bob": 30, "Charlie": 35}
for k, v in ages.items():
    print(f"{k} is {v} years old")
```

#### values() only

```python
ages = {"Alice": 25, "Bob": 30, "Charlie": 35}
for value in ages.values():
    print(value)
```

#### sum() with values()

```python
ages = {"Alice": 25, "Bob": 30, "Charlie": 35}
total = sum(ages.values())
```

### Julia

#### Iterate over key-value pairs

```julia
ages = Dict("Alice" => 25, "Bob" => 30, "Charlie" => 35)
for (key, value) in ages
    println("$key: $value")
end
```

#### Alternative unpacking

```julia
ages = Dict("Alice" => 25, "Bob" => 30, "Charlie" => 35)
for pair in ages
    println("$(pair.first): $(pair.second)")
end
```

#### keys() only

```julia
ages = Dict("Alice" => 25, "Bob" => 30, "Charlie" => 35)
for key in keys(ages)
    println(key)
end
```

#### values() only

```julia
ages = Dict("Alice" => 25, "Bob" => 30, "Charlie" => 35)
for value in values(ages)
    println(value)
end
```

#### pairs() iteration

```julia
ages = Dict("Alice" => 25, "Bob" => 30, "Charlie" => 35)
for (k, v) in pairs(ages)
    println("$k => $v")
end
```

### TypeScript

#### for-in over object keys

```typescript
let ages: { [key: string]: number } = {
    "Alice": 25,
    "Bob": 30,
    "Charlie": 35
};

for (let key in ages) {
    console.log(`${key}: ${ages[key]}`);
}
```

#### for-in with hasOwnProperty

```typescript
let ages: { [key: string]: number } = {
    "Alice": 25,
    "Bob": 30,
    "Charlie": 35
};

for (let key in ages) {
    if (ages.hasOwnProperty(key)) {
        console.log(`${key}: ${ages[key]}`);
    }
}
```

#### Object.keys()

```typescript
let ages = { "Alice": 25, "Bob": 30, "Charlie": 35 };
for (let key of Object.keys(ages)) {
    console.log(`${key}: ${ages[key]}`);
}
```

#### Object.values()

```typescript
let ages = { "Alice": 25, "Bob": 30, "Charlie": 35 };
for (let value of Object.values(ages)) {
    console.log(value);
}
```

#### Object.entries()

```typescript
let ages = { "Alice": 25, "Bob": 30, "Charlie": 35 };
for (let [key, value] of Object.entries(ages)) {
    console.log(`${key}: ${value}`);
}
```

#### Map iteration (default)

```typescript
let ages = new Map<string, number>([
    ["Alice", 25],
    ["Bob", 30],
    ["Charlie", 35]
]);

for (let [key, value] of ages) {
    console.log(`${key}: ${value}`);
}
```

#### Map entries()

```typescript
let ages = new Map<string, number>([
    ["Alice", 25],
    ["Bob", 30]
]);

for (let [key, value] of ages.entries()) {
    console.log(`${key}: ${value}`);
}
```

#### Map keys()

```typescript
let ages = new Map<string, number>([
    ["Alice", 25],
    ["Bob", 30]
]);

for (let key of ages.keys()) {
    console.log(key);
}
```

#### Map values()

```typescript
let ages = new Map<string, number>([
    ["Alice", 25],
    ["Bob", 30]
]);

for (let value of ages.values()) {
    console.log(value);
}
```

#### Map forEach()

```typescript
let ages = new Map<string, number>([
    ["Alice", 25],
    ["Bob", 30]
]);

ages.forEach((value, key) => {
    console.log(`${key}: ${value}`);
});
```

## Nested Iteration

### C++

#### Nested range-based for

```cpp
std::vector<std::vector<int>> matrix = {
    {1, 2, 3},
    {4, 5, 6},
    {7, 8, 9}
};

for (const auto& row : matrix) {
    for (const auto& element : row) {
        std::cout << element << " ";
    }
    std::cout << std::endl;
}
```

#### Nested with indices

```cpp
std::vector<std::vector<int>> matrix = {
    {1, 2, 3},
    {4, 5, 6},
    {7, 8, 9}
};

for (size_t i = 0; i < matrix.size(); ++i) {
    for (size_t j = 0; j < matrix[i].size(); ++j) {
        std::cout << matrix[i][j] << " ";
    }
    std::cout << std::endl;
}
```

#### Structured binding with nested loop

```cpp
std::vector<std::pair<std::string, std::vector<int>>> data = {
    {"Group A", {1, 2, 3}},
    {"Group B", {4, 5, 6}}
};

for (const auto& [name, values] : data) {
    std::cout << name << ": ";
    for (const auto& value : values) {
        std::cout << value << " ";
    }
    std::cout << std::endl;
}
```

### Python

#### Nested for loops

```python
matrix = [
    [1, 2, 3],
    [4, 5, 6],
    [7, 8, 9]
]

for row in matrix:
    for element in row:
        print(element, end=" ")
    print()
```

#### Nested with enumerate()

```python
matrix = [
    [1, 2, 3],
    [4, 5, 6],
    [7, 8, 9]
]

for i, row in enumerate(matrix):
    for j, element in enumerate(row):
        print(f"[{i}][{j}] = {element}")
```

#### Flatten with nested comprehension

```python
matrix = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]
flat = [element for row in matrix for element in row]
```

#### Nested comprehension for matrix

```python
table = [[i * j for j in range(1, 4)] for i in range(1, 4)]
```

#### Filter in nested comprehension

```python
matrix = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]
even_elements = [element for row in matrix for element in row if element % 2 == 0]
```

### Julia

#### Nested for loops

```julia
matrix = [
    [1, 2, 3],
    [4, 5, 6],
    [7, 8, 9]
]

for row in matrix
    for element in row
        print("$element ")
    end
    println()
end
```

#### Nested with enumerate()

```julia
matrix = [
    [1, 2, 3],
    [4, 5, 6],
    [7, 8, 9]
]

for (i, row) in enumerate(matrix)
    for (j, element) in enumerate(row)
        println("[$i][$j] = $element")
    end
end
```

#### Compact nested loop (one line)

```julia
for i in 1:3, j in 1:3
    println("($i, $j)")
end
```

#### Three-dimensional compact loop

```julia
for i in 1:2, j in 1:2, k in 1:2
    println("($i, $j, $k)")
end
```

### TypeScript

#### Nested for-of loops

```typescript
let matrix: number[][] = [
    [1, 2, 3],
    [4, 5, 6],
    [7, 8, 9]
];

for (let row of matrix) {
    for (let element of row) {
        console.log(element);
    }
}
```

#### Nested with entries()

```typescript
let matrix: number[][] = [
    [1, 2, 3],
    [4, 5, 6],
    [7, 8, 9]
];

for (let [i, row] of matrix.entries()) {
    for (let [j, element] of row.entries()) {
        console.log(`[${i}][${j}] = ${element}`);
    }
}
```

#### Traditional nested for

```typescript
let matrix: number[][] = [
    [1, 2, 3],
    [4, 5, 6],
    [7, 8, 9]
];

for (let i = 0; i < matrix.length; i++) {
    for (let j = 0; j < matrix[i].length; j++) {
        console.log(matrix[i][j]);
    }
}
```

#### Nested forEach()

```typescript
let matrix: number[][] = [[1, 2, 3], [4, 5, 6], [7, 8, 9]];

matrix.forEach((row, i) => {
    row.forEach((element, j) => {
        console.log(`[${i}][${j}] = ${element}`);
    });
});
```

#### Flatten with flatMap()

```typescript
let matrix: number[][] = [[1, 2, 3], [4, 5, 6], [7, 8, 9]];
let flat = matrix.flatMap(row => row);
```

## Parallel/Concurrent Iteration

### C++

#### Sequential execution policy

```cpp
#include <execution>
#include <algorithm>

std::vector<int> numbers(1000000);
std::for_each(std::execution::seq, 
    numbers.begin(), numbers.end(),
    [](int& n) { n *= 2; });
```

#### Parallel execution policy

```cpp
#include <execution>
#include <algorithm>

std::vector<int> numbers(1000000);
std::for_each(std::execution::par,
    numbers.begin(), numbers.end(),
    [](int& n) { n *= 2; });
```

#### Parallel unsequenced execution

```cpp
#include <execution>
#include <algorithm>

std::vector<int> numbers(1000000);
std::for_each(std::execution::par_unseq,
    numbers.begin(), numbers.end(),
    [](int& n) { n *= 2; });
```

#### OpenMP parallel for

```cpp
#include <omp.h>

std::vector<int> numbers(1000);

#pragma omp parallel for
for (size_t i = 0; i < numbers.size(); ++i) {
    numbers[i] *= 2;
}
```

#### OpenMP with reduction

```cpp
#include <omp.h>

std::vector<int> numbers(1000);
int sum = 0;

#pragma omp parallel for reduction(+:sum)
for (size_t i = 0; i < numbers.size(); ++i) {
    sum += numbers[i];
}
```

### Python

#### Multiprocessing Pool map

```python
from multiprocessing import Pool

def square(x):
    return x ** 2

numbers = list(range(1000))

with Pool(processes=4) as pool:
    result = pool.map(square, numbers)
```

#### Multiprocessing Pool starmap

```python
from multiprocessing import Pool

data = [(1, 2), (3, 4), (5, 6)]

with Pool() as pool:
    result = pool.starmap(lambda x, y: x + y, data)
```

#### ThreadPoolExecutor

```python
from concurrent.futures import ThreadPoolExecutor

numbers = list(range(100))

with ThreadPoolExecutor(max_workers=4) as executor:
    result = list(executor.map(lambda x: x ** 2, numbers))
```

#### ProcessPoolExecutor

```python
from concurrent.futures import ProcessPoolExecutor

numbers = list(range(100))

with ProcessPoolExecutor(max_workers=4) as executor:
    result = list(executor.map(lambda x: x ** 2, numbers))
```

### Julia

#### @threads for parallel loop

```julia
using Base.Threads

numbers = collect(1:1000)

@threads for i in eachindex(numbers)
    numbers[i] *= 2
end
```

#### @threads with atomic reduction

```julia
using Base.Threads

numbers = collect(1:1000)
sum = Threads.Atomic{Int}(0)

@threads for num in numbers
    Threads.atomic_add!(sum, num)
end
```

#### pmap() for parallel map

```julia
using Distributed

addprocs(4)

numbers = 1:1000
result = pmap(x -> x^2, numbers)
```

#### @distributed for parallel loops

```julia
using Distributed

sum = @distributed (+) for i in 1:1000
    i^2
end
```

### TypeScript

#### Promise.all for parallel async

```typescript
async function processItem(item: number): Promise<number> {
    return item * 2;
}

let numbers = [1, 2, 3, 4, 5];

let promises = numbers.map(num => processItem(num));
let results = await Promise.all(promises);
```

#### Sequential async with for-of

```typescript
async function processItem(item: number): Promise<number> {
    return item * 2;
}

let numbers = [1, 2, 3, 4, 5];

for (let num of numbers) {
    let result = await processItem(num);
    console.log(result);
}
```

#### Worker threads

```typescript
import { Worker } from 'worker_threads';

function runWorker(data: number): Promise<number> {
    return new Promise((resolve, reject) => {
        const worker = new Worker('./worker.js', { workerData: data });
        worker.on('message', resolve);
        worker.on('error', reject);
    });
}

let numbers = [1, 2, 3, 4, 5];
let promises = numbers.map(num => runWorker(num));
let results = await Promise.all(promises);
```

## Comparison Summary

| Feature | C++ | Python | Julia | TypeScript |
|---------|-----|--------|-------|------------|
| **Range-based for** | `for (auto x : vec)` | `for x in list:` | `for x in arr` | `for (let x of arr)` |
| **Index iteration** | `for (size_t i=0; ...)` | `for i in range(len(...))` | `for i in eachindex(...)` | `for (let i=0; ...)` |
| **Iterator access** | `.begin()`, `.end()` | `iter()`, `next()` | Native iterator | `Symbol.iterator` |
| **Enumerate** | Manual with counter | `enumerate()` | `enumerate()` | `.entries()` |
| **Reverse iteration** | `.rbegin()`, `.rend()` | `reversed()` | `reverse()` | Reverse loop or `.reverse()` |
| **Key-value iteration** | Structured binding | `.items()` | Native unpacking | `Object.entries()` |
| **String iteration** | Char by char | Char by char | Char by char | Char by char |
| **Parallel iteration** | `<execution>`, OpenMP | `multiprocessing` | `@threads` | Worker threads |

## Key Differences

### C++
- **Range-based for** - clean syntax with `auto`
- **Iterator-based** - explicit iterator control
- **Reference vs value** - `&` for reference, no `&` for copy
- **Reverse iterators** - `.rbegin()`, `.rend()`
- **Structured bindings** (C++17) - unpack pairs/tuples

### Python
- **for-in only** - no traditional C-style for loop
- **enumerate()** - built-in index access
- **Multiple unpacking** - `for k, v in dict.items()`
- **reversed()** - simple reverse iteration
- **Generator-friendly** - works with any iterable

### Julia
- **1-indexed** - arrays start at 1, not 0
- **eachindex()** - safe, efficient indexing
- **end keyword** - last index in array
- **Compact nested syntax** - `for i in 1:3, j in 1:3`
- **Broadcasting** - `.` operator for element-wise

### TypeScript
- **for-of vs for-in** - values vs indices/keys
- **.entries()** - get index-value pairs
- **forEach** - functional but no break/continue
- **Map/Object iteration** - different syntaxes
- **Async iteration** - `for await` for async iterables