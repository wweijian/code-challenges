# Multiple Dispatch vs Function Overloading

## The Key Differences

### 1. Runtime vs Compile-Time Resolution

#### C++ Overloading (Compile-Time)
```cpp
class Animal {};
class Dog : public Animal {};
class Cat : public Animal {};

void interact(Animal* a, Animal* b) {
    cout << "Two animals" << endl;
}

void interact(Dog* d, Cat* c) {
    cout << "Dog chases cat" << endl;
}
```

**THE PROBLEM:**
```cpp
Animal* obj1 = new Dog();  // Declared as Animal*
Animal* obj2 = new Cat();  // Declared as Animal*

interact(obj1, obj2);      // Prints "Two animals" 
                           // NOT "Dog chases cat"!
```

Uses DECLARED types, not actual types

The compiler looks at **declared types** (both are `Animal*`), not **actual types** (Dog and Cat).

#### Julia Multiple Dispatch (Runtime)
```julia
struct Animal end
struct Dog <: Animal end
struct Cat <: Animal end

interact(a::Animal, b::Animal) = println("Two animals")
interact(d::Dog, c::Cat) = println("Dog chases cat")
```

Works correctly!
```julia
obj1::Animal = Dog()   # Declared as Animal
obj2::Animal = Cat()   # Declared as Animal

interact(obj1, obj2)   # Prints "Dog chases cat"
```

Uses ACTUAL types!

Julia checks the **actual runtime types** and picks the right method.

---

### 2. Extensibility (The Big One!)

#### C++ Overloading (Limited Extension)

Library code (you can't modify)
```cpp
class Matrix {
public:
    Matrix operator+(const Matrix& other);  // Defined here
};
```

Your code
```cpp
class SparseMatrix : public Matrix {};
```

You CANNOT do this:
```cpp
Matrix operator+(const Matrix& a, const SparseMatrix& b) {
    // ERROR! Can't add overloads to existing class from outside
}
```

You're stuck with inheritance or workarounds

#### Julia Multiple Dispatch (Open Extension)

Library code (you don't own this)
```julia
struct Matrix
    data::Array{Float64, 2}
end

+(a::Matrix, b::Matrix) = # library's addition
```

Your code - you can extend it!
```julia
struct SparseMatrix
    data::SparseArrays.SparseMatrixCSC
end
```

Add your own method to the existing + function
```julia
import Base: +
+(a::Matrix, b::SparseMatrix) = # your optimized version
+(a::SparseMatrix, b::Matrix) = # your optimized version
+(a::SparseMatrix, b::SparseMatrix) = # your optimized version
```

Now + works with your new types!
```julia
m = Matrix([1.0 2.0])
s = SparseMatrix(sparse([1.0 2.0]))
m + s  # Uses YOUR method!
```

**This is huge**: You can extend functions you don't own for types you created!

---

### 3. Symmetry

#### C++ (Asymmetric)
```cpp
class String {
    String operator+(const String& other);  // String + String
    String operator+(int num);              // String + int
};

String s = "hello";
s + 5;        // OK - String.operator+(int)
5 + s;        // ERROR! int doesn't have operator+(String)
```

Need to define global function
```cpp
String operator+(int num, const String& s) {
    // Separate implementation needed
}
```

#### Julia (Symmetric)
```julia
struct MyString
    value::String
end

+(a::MyString, b::Int) = MyString(a.value * string(b))
```

Both directions work automatically!
```julia
s = MyString("hello")
s + 5         # Works
5 + s         # Also works! Julia tries both orders
```

---

### 4. All Arguments Matter Equally

#### C++ (Receiver-Centric)
```cpp
class Shape {
    virtual bool collidesWith(Shape& other) { }
};

class Circle : public Shape {
    bool collidesWith(Shape& other) override {
        // Only knows 'this' is Circle
        // Have to manually check type of 'other'
        if (Circle* c = dynamic_cast<Circle*>(&other)) {
            // Circle-Circle collision
        } else if (Box* b = dynamic_cast<Box*>(&other)) {
            // Circle-Box collision
        }
        // Messy!
    }
};
```

You have to manually check types and cast. The dispatch only worked on the first object.

#### Julia (All Arguments Equal)

Clean, separate functions for each combination
```julia
struct Circle end
struct Box end
struct Triangle end

collide(a::Circle, b::Circle) = "Circle-Circle physics"
collide(a::Circle, b::Box) = "Circle-Box physics"
collide(a::Circle, b::Triangle) = "Circle-Triangle physics"
collide(a::Box, b::Box) = "Box-Box physics"
collide(a::Box, b::Triangle) = "Box-Triangle physics"
collide(a::Triangle, b::Triangle) = "Triangle-Triangle physics"
```

Julia picks the right one based on BOTH types
```julia
collide(Circle(), Box())      # Automatically chooses correct method
```

No casting, no type checking, no if-else chains!

---

## Side-by-Side Comparison

### Problem: Add custom behavior for library types

#### C++ Approach

Library provides:
```cpp
class Image { };
double distance(Image& a, Image& b);
```

You want to add:
```cpp
class MyImage : public Image { };
```

You CANNOT extend distance() for MyImage combinations

Must either:
1. Modify library (not possible)
2. Use inheritance + virtual functions (limited)
3. Create new function name (breaks API)
4. Template metaprogramming (complex)

#### Julia Approach

Library provides:
```julia
struct Image end
distance(a::Image, b::Image) = # library implementation
```

You add:
```julia
struct MyImage end
```

Just extend it!
```julia
distance(a::MyImage, b::MyImage) = # your optimized version
distance(a::Image, b::MyImage) = # mixed case
distance(a::MyImage, b::Image) = # mixed case reversed
```

Done! Works seamlessly with library code

---

## Real Example: The Expression Problem

Someone else's code
```julia
abstract type Expr end
struct Num <: Expr
    value::Float64
end
struct Add <: Expr
    left::Expr
    right::Expr
end

eval(e::Num) = e.value
eval(e::Add) = eval(e.left) + eval(e.right)
```

Later, YOU add a new type
```julia
struct Multiply <: Expr
    left::Expr
    right::Expr
end
```

Extend the existing eval function
```julia
eval(e::Multiply) = eval(e.left) * eval(e.right)
```

Works perfectly with existing code!
```julia
code = Add(Num(5), Multiply(Num(3), Num(2)))
eval(code)  # 11
```

In C++/Java, you'd need to modify the original `eval` function or use the Visitor pattern (complex!).

---

## Summary Table

| Feature | Function Overloading (C++) | Multiple Dispatch (Julia) |
|---------|---------------------------|---------------------------|
| **Type Resolution** | Compile-time, static types | Runtime, actual types |
| **Extensibility** | Limited to class definition | Open - anyone can extend |
| **Symmetry** | Asymmetric (receiver special) | Symmetric (all args equal) |
| **Type Checking** | Manual casting often needed | Automatic |
| **Adding to Existing Functions** | Usually impossible | Easy and common |
| **Performance** | Fast (compile-time) | Fast (JIT-compiled) |

---

## The Real Difference

**Overloading** = "I'm defining multiple versions of a function **I own**"

**Multiple Dispatch** = "I'm extending a function **anyone can own** with new type combinations"

It's the difference between:
- **Closed system**: Only the original author can add behavior
- **Open system**: Anyone can extend any function for new types

This makes Julia extremely composable - libraries work together without anyone planning for it!